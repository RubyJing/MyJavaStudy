享元模式（Flyweight Design Pattern）
所谓“享元”，顾名思义就是被共享的单元。
享元模式的意图是复用对象，节省内存，前提是享元对象是不可变对象。

具体来说，当一个系统中存在大量重复对象的时候，如果这些重复的对象是不可变对象，我们就可以利用享元模式
将对象设计成享元，在内存中只保留一份实例，供多处代码引用。这样可以减少内存中对象的数量，起到节省内存的目的。
实际上，不仅仅相同对象可以设计成享元，对于相似对象，我们也可以将这些对象中相同的部分（字段）提取出来，
设计成享元，让这些大量相似对象引用这些享元。

“不可变对象”：一旦通过构造函数初始化完成之后，它的状态（对象的成员变量或者属性）就不会再被修改了；
                所以，不可变对象不能暴露任何set()等修改内部状态的方法。

具体实例：
假设我们在开发一个棋牌游戏（比如象棋）。
一个游戏厅中有成千上万个“房间”，每个房间对应一个棋局。
棋局要保存每个棋子的数据，比如：棋子类型（将、相、士、炮等）、棋子颜色（红方、黑方）、棋子在棋局中的位置。
利用这些数据，我们就能显示一个完整的棋盘给玩家。

具体的代码如下所示。
其中，ChessPiece 类表示棋子，ChessBoard 类表示一个棋局，里面保存了象棋中 30 个棋子的信息

为了记录每个房间当前的棋局情况，我们需要给每个房间都创建一个 ChessBoard 棋局对象。
因为游戏大厅中有成千上万的房间（实际上，百万人同时在线的游戏大厅也有很多），那保存这么多棋局对象就会消耗大量的内存。有没有什么办法来节省内存呢？

像刚刚的实现方式，在内存中会有大量的相似对象。这些相似对象的 id、text、color 都是相同的，唯独 positionX、positionY 不同。
实际上，我们可以将棋子的 id、text、color 属性拆分出来，设计成独立的类，并且作为享元供多个棋盘复用。这样，棋盘只需要记录每个棋子的位置信息就可以了。